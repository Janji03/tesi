#include <antlr4-runtime.h>
#include <fstream>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

#include "AstBuilderVisitor.h"
#include "AstPrinter.h"
#include "ErrorListener.h"

// Generated by ANTLR
#include "ToyChoreoLexer.h"
#include "ToyChoreoParser.h"

static std::string readFileToString(const std::string& path) {
  std::ifstream in(path, std::ios::binary);
  if (!in) throw std::runtime_error("Cannot open file: " + path);
  std::ostringstream ss;
  ss << in.rdbuf();
  return ss.str();
}

static std::vector<std::string> splitLines(const std::string& s) {
  std::vector<std::string> lines;
  std::string cur;
  cur.reserve(128);

  for (char c : s) {
    if (c == '\n') {
      if (!cur.empty() && cur.back() == '\r') cur.pop_back();
      lines.push_back(cur);
      cur.clear();
    } else {
      cur.push_back(c);
    }
  }
  if (!cur.empty()) {
    if (!cur.empty() && cur.back() == '\r') cur.pop_back();
    lines.push_back(cur);
  }
  return lines;
}

static void printErrorWithContext(const std::string& filename,
                                  const std::vector<std::string>& lines,
                                  size_t line1based,
                                  size_t column0based,
                                  const std::string& message) {
  std::cerr << "  " << filename << ":" << line1based << ":" << column0based
            << " " << message << "\n";

  if (line1based == 0 || line1based > lines.size()) return;

  const std::string& textLine = lines[line1based - 1];
  std::cerr << "    " << textLine << "\n";

  std::cerr << "    ";
  for (size_t i = 0; i < column0based; ++i) std::cerr << ' ';
  std::cerr << "^\n";
}

static void printTokens(ToyChoreoLexer& lexer) {
  while (true) {
    auto tokPtr = lexer.nextToken();
    antlr4::Token* t = tokPtr.get();
    if (!t) break;

    const auto type = t->getType();
    const auto line = t->getLine();
    const auto col  = t->getCharPositionInLine();
    const auto text = t->getText();

    if (type == antlr4::Token::EOF) {
      std::cout << line << ":" << col << "  EOF\n";
      break;
    }

    const auto sym = lexer.getVocabulary().getSymbolicName(type);
    const auto lit = lexer.getVocabulary().getLiteralName(type);

    std::string name;
    if (!sym.empty()) {
      name = std::string(sym);
    } else if (!lit.empty()) {
      name = std::string(lit);
    } else {
      name = std::string("#") + std::to_string(type);
    }

    std::cout << line << ":" << col << "  " << name << "  \"" << text << "\"\n";
  }
}

static void usage() {
  std::cerr
    << "Usage:\n"
    << "  toy_choreo parse  <file.toy>\n"
    << "  toy_choreo ast    <file.toy>\n"
    << "  toy_choreo tokens <file.toy>\n";
}

int main(int argc, char** argv) {
  if (argc != 3) {
    usage();
    return 2;
  }

  const std::string command = argv[1];
  const std::string filename = argv[2];

  try {
    const std::string input = readFileToString(filename);
    const auto lines = splitLines(input);

    antlr4::ANTLRInputStream inputStream(input);
    ToyChoreoLexer lexer(&inputStream);

    lexer.removeErrorListeners();
    CollectingErrorListener errListener;
    lexer.addErrorListener(&errListener);

    if (command == "tokens") {
      printTokens(lexer);

      if (errListener.hasErrors()) {
        std::cerr << "Lexical errors:\n";
        for (const auto& e : errListener.getErrors()) {
          printErrorWithContext(filename, lines, e.line, e.column, e.message);
        }
        return 1;
      }
      return 0;
    }

    // For parse/ast we need the parser
    antlr4::CommonTokenStream tokens(&lexer);
    ToyChoreoParser parser(&tokens);

    parser.removeErrorListeners();
    parser.addErrorListener(&errListener);

    auto* tree = parser.program();

    if (errListener.hasErrors()) {
      std::cerr << "Syntax errors:\n";
      for (const auto& e : errListener.getErrors()) {
        printErrorWithContext(filename, lines, e.line, e.column, e.message);
      }
      return 1;
    }

    if (command == "parse") {
      std::cout << "Parse OK\n";
      return 0;
    }

    if (command == "ast") {
      std::cout << "Parse OK\n";
      AstBuilderVisitor builder;
      ast::Program prog = builder.build(tree);

      ast::Printer printer(std::cout);
      printer.print(prog);
      return 0;
    }

    std::cerr << "Unknown command: " << command << "\n";
    usage();
    return 2;

  } catch (const std::exception& ex) {
    std::cerr << "Fatal: " << ex.what() << "\n";
    return 3;
  }
}
